/*
 * Bitbucket API
 *
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * API version: 2.0
 * Contact: support@bitbucket.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bitbucket_client
import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// RefsApiService RefsApi service
type RefsApiService service

type ApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest struct {
	ctx _context.Context
	ApiService *RefsApiService
	repoSlug string
	workspace string
	q *string
	sort *string
}

func (r ApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest) Q(q string) ApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest {
	r.q = &q
	return r
}
func (r ApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest) Sort(sort string) ApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest {
	r.sort = &sort
	return r
}

func (r ApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest) Execute() (PaginatedBranches, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugRefsBranchesGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugRefsBranchesGet Method for RepositoriesWorkspaceRepoSlugRefsBranchesGet
 * Returns a list of all open branches within the specified repository.
Results will be in the order the source control manager returns them.

```
$ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches | jq .
{
  "pagelen": 10,
  "values": [
    {
      "heads": [
        {
          "hash": "f1a0933ce59e809f190602655e22ae6ec107c397",
          "type": "commit",
          "links": {
            "self": {
              "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397"
            },
            "html": {
              "href": "https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397"
            }
          }
        }
      ],
      "type": "named_branch",
      "name": "default",
      "links": {
        "commits": {
          "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commits/default"
        },
        "self": {
          "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/default"
        },
        "html": {
          "href": "https://bitbucket.org/seanfarley/mercurial/branch/default"
        }
      },
      "target": {
        "hash": "f1a0933ce59e809f190602655e22ae6ec107c397",
        "repository": {
          "links": {
            "self": {
              "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial"
            },
            "html": {
              "href": "https://bitbucket.org/seanfarley/mercurial"
            },
            "avatar": {
              "href": "https://bitbucket.org/seanfarley/mercurial/avatar/32/"
            }
          },
          "type": "repository",
          "name": "mercurial",
          "full_name": "seanfarley/mercurial",
          "uuid": "{73dcbd61-e506-4fc1-9ecd-31be2b6d6031}"
        },
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397"
          },
          "comments": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/comments"
          },
          "patch": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/patch/f1a0933ce59e809f190602655e22ae6ec107c397"
          },
          "html": {
            "href": "https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397"
          },
          "diff": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/diff/f1a0933ce59e809f190602655e22ae6ec107c397"
          },
          "approve": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/approve"
          },
          "statuses": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/statuses"
          }
        },
        "author": {
          "raw": "Martin von Zweigbergk <martinvonz@google.com>",
          "type": "author",
          "user": {
            "username": "martinvonz",
            "nickname": "martinvonz",
            "display_name": "Martin von Zweigbergk",
            "type": "user",
            "uuid": "{fdb0e657-3ade-4fad-a136-95f1ffe4a5ac}",
            "links": {
              "self": {
                "href": "https://api.bitbucket.org/2.0/users/martinvonz"
              },
              "html": {
                "href": "https://bitbucket.org/martinvonz/"
              },
              "avatar": {
                "href": "https://bitbucket.org/account/martinvonz/avatar/32/"
              }
            }
          }
        },
        "parents": [
          {
            "hash": "5523aabb85c30ebc2b8e29aadcaf5e13fa92b375",
            "type": "commit",
            "links": {
              "self": {
                "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375"
              },
              "html": {
                "href": "https://bitbucket.org/seanfarley/mercurial/commits/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375"
              }
            }
          }
        ],
        "date": "2018-02-01T18:44:49+00:00",
        "message": "config: replace a for-else by any()",
        "type": "commit"
      }
    },
    {
      "heads": [
        {
          "hash": "1d60ad093792706e1dc7a52b20942593f2c19655",
          "type": "commit",
          "links": {
            "self": {
              "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655"
            },
            "html": {
              "href": "https://bitbucket.org/seanfarley/mercurial/commits/1d60ad093792706e1dc7a52b20942593f2c19655"
            }
          }
        }
      ],
      "type": "named_branch",
      "name": "stable",
      "links": {
        "commits": {
          "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commits/stable"
        },
        "self": {
          "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/stable"
        },
        "html": {
          "href": "https://bitbucket.org/seanfarley/mercurial/branch/stable"
        }
      },
      "target": {
        "hash": "1d60ad093792706e1dc7a52b20942593f2c19655",
        "repository": {
          "links": {
            "self": {
              "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial"
            },
            "html": {
              "href": "https://bitbucket.org/seanfarley/mercurial"
            },
            "avatar": {
              "href": "https://bitbucket.org/seanfarley/mercurial/avatar/32/"
            }
          },
          "type": "repository",
          "name": "mercurial",
          "full_name": "seanfarley/mercurial",
          "uuid": "{73dcbd61-e506-4fc1-9ecd-31be2b6d6031}"
        },
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655"
          },
          "comments": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655/comments"
          },
          "patch": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/patch/1d60ad093792706e1dc7a52b20942593f2c19655"
          },
          "html": {
            "href": "https://bitbucket.org/seanfarley/mercurial/commits/1d60ad093792706e1dc7a52b20942593f2c19655"
          },
          "diff": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/diff/1d60ad093792706e1dc7a52b20942593f2c19655"
          },
          "approve": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655/approve"
          },
          "statuses": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655/statuses"
          }
        },
        "author": {
          "raw": "Augie Fackler <raf@durin42.com>",
          "type": "author",
          "user": {
            "username": "durin42",
            "nickname": "durin42",
            "display_name": "Augie Fackler",
            "type": "user",
            "uuid": "{e07dc61f-bb05-4218-b43a-d991f26be65a}",
            "links": {
              "self": {
                "href": "https://api.bitbucket.org/2.0/users/durin42"
              },
              "html": {
                "href": "https://bitbucket.org/durin42/"
              },
              "avatar": {
                "href": "https://bitbucket.org/account/durin42/avatar/32/"
              }
            }
          }
        },
        "parents": [
          {
            "hash": "56a0da11bde519d79168e890df4bcf0da62f0a7b",
            "type": "commit",
            "links": {
              "self": {
                "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/56a0da11bde519d79168e890df4bcf0da62f0a7b"
              },
              "html": {
                "href": "https://bitbucket.org/seanfarley/mercurial/commits/56a0da11bde519d79168e890df4bcf0da62f0a7b"
              }
            }
          }
        ],
        "date": "2018-02-01T19:13:41+00:00",
        "message": "Added signature for changeset d334afc585e2",
        "type": "commit"
      }
    }
  ],
  "page": 1,
  "size": 2
}
```

Branches support [filtering and sorting](../../../../../meta/filtering)
that can be used to search for specific branches. For instance, to find
all branches that have "stab" in their name:

```
curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches -G --data-urlencode 'q=name ~ "stab"'
```

By default, results will be in the order the underlying source control system returns them and identical to
the ordering one sees when running "$ hg branches" or "$ git branch --list". Note that this follows simple
lexical ordering of the ref names.

This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are
sorted ["v10", "v11", "v9"] instead of ["v9", "v10", "v11"].

Sorting can be changed using the ?q= query parameter. When using ?q=name to explicitly sort on ref name,
Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsBranchesGet(ctx _context.Context, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedBranches
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsBranchesGetExecute(r ApiRepositoriesWorkspaceRepoSlugRefsBranchesGetRequest) (PaginatedBranches, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedBranches
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RefsApiService.RepositoriesWorkspaceRepoSlugRefsBranchesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/refs/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteRequest struct {
	ctx _context.Context
	ApiService *RefsApiService
	name string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugRefsBranchesNameDelete Method for RepositoriesWorkspaceRepoSlugRefsBranchesNameDelete
 * Delete a branch in the specified repository.

The main branch is not allowed to be deleted and will return a 400
response.

For Git, the branch name should not include any prefixes (e.g.
refs/heads). For Mercurial, this closes all open heads on the branch,
sets the author of the commit to the authenticated caller, and changes
the date to the datetime of the call.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name The name of the branch.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteRequest
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsBranchesNameDelete(ctx _context.Context, name string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteRequest {
	return ApiRepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteExecute(r ApiRepositoriesWorkspaceRepoSlugRefsBranchesNameDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RefsApiService.RepositoriesWorkspaceRepoSlugRefsBranchesNameDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/refs/branches/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugRefsBranchesNameGetRequest struct {
	ctx _context.Context
	ApiService *RefsApiService
	name string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugRefsBranchesNameGetRequest) Execute() (Branch, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugRefsBranchesNameGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugRefsBranchesNameGet Method for RepositoriesWorkspaceRepoSlugRefsBranchesNameGet
 * Returns a branch object within the specified repository.

```
$ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/default | jq .
{
  "heads": [
    {
      "hash": "f1a0933ce59e809f190602655e22ae6ec107c397",
      "type": "commit",
      "links": {
        "self": {
          "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397"
        },
        "html": {
          "href": "https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397"
        }
      }
    }
  ],
  "type": "named_branch",
  "name": "default",
  "links": {
    "commits": {
      "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commits/default"
    },
    "self": {
      "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/default"
    },
    "html": {
      "href": "https://bitbucket.org/seanfarley/mercurial/branch/default"
    }
  },
  "target": {
    "hash": "f1a0933ce59e809f190602655e22ae6ec107c397",
    "repository": {
      "links": {
        "self": {
          "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial"
        },
        "html": {
          "href": "https://bitbucket.org/seanfarley/mercurial"
        },
        "avatar": {
          "href": "https://bitbucket.org/seanfarley/mercurial/avatar/32/"
        }
      },
      "type": "repository",
      "name": "mercurial",
      "full_name": "seanfarley/mercurial",
      "uuid": "{73dcbd61-e506-4fc1-9ecd-31be2b6d6031}"
    },
    "links": {
      "self": {
        "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397"
      },
      "comments": {
        "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/comments"
      },
      "patch": {
        "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/patch/f1a0933ce59e809f190602655e22ae6ec107c397"
      },
      "html": {
        "href": "https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397"
      },
      "diff": {
        "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/diff/f1a0933ce59e809f190602655e22ae6ec107c397"
      },
      "approve": {
        "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/approve"
      },
      "statuses": {
        "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/statuses"
      }
    },
    "author": {
      "raw": "Martin von Zweigbergk <martinvonz@google.com>",
      "type": "author",
      "user": {
        "username": "martinvonz",
        "nickname": "martinvonz",
        "display_name": "Martin von Zweigbergk",
        "type": "user",
        "uuid": "{fdb0e657-3ade-4fad-a136-95f1ffe4a5ac}",
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/users/martinvonz"
          },
          "html": {
            "href": "https://bitbucket.org/martinvonz/"
          },
          "avatar": {
            "href": "https://bitbucket.org/account/martinvonz/avatar/32/"
          }
        }
      }
    },
    "parents": [
      {
        "hash": "5523aabb85c30ebc2b8e29aadcaf5e13fa92b375",
        "type": "commit",
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375"
          },
          "html": {
            "href": "https://bitbucket.org/seanfarley/mercurial/commits/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375"
          }
        }
      }
    ],
    "date": "2018-02-01T18:44:49+00:00",
    "message": "config: replace a for-else by any()",
    "type": "commit"
  }
}
```

This call requires authentication. Private repositories require the
caller to authenticate with an account that has appropriate
authorization.

For Git, the branch name should not include any prefixes (e.g.
refs/heads).

For Mercurial, the response will include an additional field that lists
the open heads.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name The name of the branch.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugRefsBranchesNameGetRequest
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsBranchesNameGet(ctx _context.Context, name string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugRefsBranchesNameGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugRefsBranchesNameGetRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Branch
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsBranchesNameGetExecute(r ApiRepositoriesWorkspaceRepoSlugRefsBranchesNameGetRequest) (Branch, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Branch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RefsApiService.RepositoriesWorkspaceRepoSlugRefsBranchesNameGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/refs/branches/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugRefsBranchesPostRequest struct {
	ctx _context.Context
	ApiService *RefsApiService
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugRefsBranchesPostRequest) Execute() (Branch, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugRefsBranchesPostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugRefsBranchesPost Method for RepositoriesWorkspaceRepoSlugRefsBranchesPost
 * Creates a new branch in the specified repository.

The payload of the POST should consist of a JSON document that
contains the name of the tag and the target hash.

```
curl https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/branches \
-s -u seanfarley -X POST -H "Content-Type: application/json" \
-d '{
    "name" : "smf/create-feature",
    "target" : {
        "hash" : "default",
    }
}'
```

This call requires authentication. Private repositories require the
caller to authenticate with an account that has appropriate
authorization.

For Git, the branch name should not include any prefixes (e.g.
refs/heads). This endpoint does support using short hash prefixes for
the commit hash, but it may return a 400 response if the provided
prefix is ambiguous. Using a full commit hash is the preferred
approach.

For Mercurial, the authenticated user making this call is the author of
the new branch commit and the date is current datetime of the call.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugRefsBranchesPostRequest
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsBranchesPost(ctx _context.Context, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugRefsBranchesPostRequest {
	return ApiRepositoriesWorkspaceRepoSlugRefsBranchesPostRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Branch
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsBranchesPostExecute(r ApiRepositoriesWorkspaceRepoSlugRefsBranchesPostRequest) (Branch, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Branch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RefsApiService.RepositoriesWorkspaceRepoSlugRefsBranchesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/refs/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugRefsGetRequest struct {
	ctx _context.Context
	ApiService *RefsApiService
	repoSlug string
	workspace string
	q *string
	sort *string
}

func (r ApiRepositoriesWorkspaceRepoSlugRefsGetRequest) Q(q string) ApiRepositoriesWorkspaceRepoSlugRefsGetRequest {
	r.q = &q
	return r
}
func (r ApiRepositoriesWorkspaceRepoSlugRefsGetRequest) Sort(sort string) ApiRepositoriesWorkspaceRepoSlugRefsGetRequest {
	r.sort = &sort
	return r
}

func (r ApiRepositoriesWorkspaceRepoSlugRefsGetRequest) Execute() (PaginatedRefs, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugRefsGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugRefsGet Method for RepositoriesWorkspaceRepoSlugRefsGet
 * Returns the branches and tags in the repository.

By default, results will be in the order the underlying source control system returns them and identical to
the ordering one sees when running "$ git show-ref". Note that this follows simple
lexical ordering of the ref names.

This can be undesirable as it does apply any natural sorting semantics, meaning for instance that refs are
sorted ["branch1", "branch10", "branch2", "v10", "v11", "v9"] instead of ["branch1", "branch2",
"branch10", "v9", "v10", "v11"].

Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name,
Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugRefsGetRequest
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsGet(ctx _context.Context, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugRefsGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugRefsGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedRefs
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsGetExecute(r ApiRepositoriesWorkspaceRepoSlugRefsGetRequest) (PaginatedRefs, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedRefs
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RefsApiService.RepositoriesWorkspaceRepoSlugRefsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/refs"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest struct {
	ctx _context.Context
	ApiService *RefsApiService
	repoSlug string
	workspace string
	q *string
	sort *string
}

func (r ApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest) Q(q string) ApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest {
	r.q = &q
	return r
}
func (r ApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest) Sort(sort string) ApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest {
	r.sort = &sort
	return r
}

func (r ApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest) Execute() (PaginatedTags, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugRefsTagsGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugRefsTagsGet Method for RepositoriesWorkspaceRepoSlugRefsTagsGet
 * Returns the tags in the repository.

By default, results will be in the order the underlying source control system returns them and identical to
the ordering one sees when running "$ hg tags" or "$ git tag --list". Note that this follows simple
lexical ordering of the ref names.

This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are
sorted ["v10", "v11", "v9"] instead of ["v9", "v10", "v11"].

Sorting can be changed using the ?sort= query parameter. When using ?sort=name to explicitly sort on ref name,
Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsTagsGet(ctx _context.Context, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedTags
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsTagsGetExecute(r ApiRepositoriesWorkspaceRepoSlugRefsTagsGetRequest) (PaginatedTags, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedTags
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RefsApiService.RepositoriesWorkspaceRepoSlugRefsTagsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/refs/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugRefsTagsNameDeleteRequest struct {
	ctx _context.Context
	ApiService *RefsApiService
	name string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugRefsTagsNameDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugRefsTagsNameDeleteExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugRefsTagsNameDelete Method for RepositoriesWorkspaceRepoSlugRefsTagsNameDelete
 * Delete a tag in the specified repository.

For Git, the tag name should not include any prefixes (e.g. refs/tags).
For Mercurial, this adds a commit to the main branch that removes the
specified tag.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name The name of the tag.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugRefsTagsNameDeleteRequest
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsTagsNameDelete(ctx _context.Context, name string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugRefsTagsNameDeleteRequest {
	return ApiRepositoriesWorkspaceRepoSlugRefsTagsNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsTagsNameDeleteExecute(r ApiRepositoriesWorkspaceRepoSlugRefsTagsNameDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RefsApiService.RepositoriesWorkspaceRepoSlugRefsTagsNameDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/refs/tags/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugRefsTagsNameGetRequest struct {
	ctx _context.Context
	ApiService *RefsApiService
	name string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugRefsTagsNameGetRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugRefsTagsNameGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugRefsTagsNameGet Method for RepositoriesWorkspaceRepoSlugRefsTagsNameGet
 * Returns the specified tag.

```
$ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8 -G | jq .
{
  "name": "3.8",
  "links": {
    "commits": {
      "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commits/3.8"
    },
    "self": {
      "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8"
    },
    "html": {
      "href": "https://bitbucket.org/seanfarley/hg/commits/tag/3.8"
    }
  },
  "tagger": {
    "raw": "Matt Mackall <mpm@selenic.com>",
    "type": "author",
    "user": {
      "username": "mpmselenic",
      "nickname": "mpmselenic",
      "display_name": "Matt Mackall",
      "type": "user",
      "uuid": "{a4934530-db4c-419c-a478-9ab4964c2ee7}",
      "links": {
        "self": {
          "href": "https://api.bitbucket.org/2.0/users/mpmselenic"
        },
        "html": {
          "href": "https://bitbucket.org/mpmselenic/"
        },
        "avatar": {
          "href": "https://bitbucket.org/account/mpmselenic/avatar/32/"
        }
      }
    }
  },
  "date": "2016-05-01T18:52:25+00:00",
  "message": "Added tag 3.8 for changeset f85de28eae32",
  "type": "tag",
  "target": {
    "hash": "f85de28eae32e7d3064b1a1321309071bbaaa069",
    "repository": {
      "links": {
        "self": {
          "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg"
        },
        "html": {
          "href": "https://bitbucket.org/seanfarley/hg"
        },
        "avatar": {
          "href": "https://bitbucket.org/seanfarley/hg/avatar/32/"
        }
      },
      "type": "repository",
      "name": "hg",
      "full_name": "seanfarley/hg",
      "uuid": "{c75687fb-e99d-4579-9087-190dbd406d30}"
    },
    "links": {
      "self": {
        "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069"
      },
      "comments": {
        "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/comments"
      },
      "patch": {
        "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/patch/f85de28eae32e7d3064b1a1321309071bbaaa069"
      },
      "html": {
        "href": "https://bitbucket.org/seanfarley/hg/commits/f85de28eae32e7d3064b1a1321309071bbaaa069"
      },
      "diff": {
        "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/diff/f85de28eae32e7d3064b1a1321309071bbaaa069"
      },
      "approve": {
        "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/approve"
      },
      "statuses": {
        "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/statuses"
      }
    },
    "author": {
      "raw": "Sean Farley <sean@farley.io>",
      "type": "author",
      "user": {
        "username": "seanfarley",
        "nickname": "seanfarley",
        "display_name": "Sean Farley",
        "type": "user",
        "uuid": "{a295f8a8-5876-4d43-89b5-3ad8c6c3c51d}",
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/users/seanfarley"
          },
          "html": {
            "href": "https://bitbucket.org/seanfarley/"
          },
          "avatar": {
            "href": "https://bitbucket.org/account/seanfarley/avatar/32/"
          }
        }
      }
    },
    "parents": [
      {
        "hash": "9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2",
        "type": "commit",
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2"
          },
          "html": {
            "href": "https://bitbucket.org/seanfarley/hg/commits/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2"
          }
        }
      }
    ],
    "date": "2016-05-01T04:21:17+00:00",
    "message": "debian: alphabetize build deps",
    "type": "commit"
  }
}
```
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name The name of the tag.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugRefsTagsNameGetRequest
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsTagsNameGet(ctx _context.Context, name string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugRefsTagsNameGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugRefsTagsNameGetRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Tag
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsTagsNameGetExecute(r ApiRepositoriesWorkspaceRepoSlugRefsTagsNameGetRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RefsApiService.RepositoriesWorkspaceRepoSlugRefsTagsNameGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/refs/tags/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest struct {
	ctx _context.Context
	ApiService *RefsApiService
	repoSlug string
	workspace string
	body *Tag
}

func (r ApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest) Body(body Tag) ApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest {
	r.body = &body
	return r
}

func (r ApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugRefsTagsPostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugRefsTagsPost Method for RepositoriesWorkspaceRepoSlugRefsTagsPost
 * Creates a new tag in the specified repository.

The payload of the POST should consist of a JSON document that
contains the name of the tag and the target hash.

```
curl https://api.bitbucket.org/2.0/repositories/jdoe/myrepo/refs/tags \
-s -u jdoe -X POST -H "Content-Type: application/json" \
-d '{
    "name" : "new-tag-name",
    "target" : {
        "hash" : "a1b2c3d4e5f6",
    }
}'
```

This endpoint does support using short hash prefixes for the commit
hash, but it may return a 400 response if the provided prefix is
ambiguous. Using a full commit hash is the preferred approach.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsTagsPost(ctx _context.Context, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest {
	return ApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Tag
 */
func (a *RefsApiService) RepositoriesWorkspaceRepoSlugRefsTagsPostExecute(r ApiRepositoriesWorkspaceRepoSlugRefsTagsPostRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RefsApiService.RepositoriesWorkspaceRepoSlugRefsTagsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/refs/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
