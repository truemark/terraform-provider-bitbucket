/*
 * Bitbucket API
 *
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * API version: 2.0
 * Contact: support@bitbucket.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bitbucket_client
import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// IssueTrackerApiService IssueTrackerApi service
type IssueTrackerApiService service

type ApiRepositoriesWorkspaceRepoSlugComponentsComponentIdGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	componentId int32
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugComponentsComponentIdGetRequest) Execute() (Component, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugComponentsComponentIdGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugComponentsComponentIdGet Method for RepositoriesWorkspaceRepoSlugComponentsComponentIdGet
 * Returns the specified issue tracker component object.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param componentId The component's id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugComponentsComponentIdGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugComponentsComponentIdGet(ctx _context.Context, componentId int32, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugComponentsComponentIdGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugComponentsComponentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		componentId: componentId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Component
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugComponentsComponentIdGetExecute(r ApiRepositoriesWorkspaceRepoSlugComponentsComponentIdGetRequest) (Component, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Component
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugComponentsComponentIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/components/{component_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"component_id"+"}", _neturl.PathEscape(parameterToString(r.componentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugComponentsGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugComponentsGetRequest) Execute() (PaginatedComponents, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugComponentsGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugComponentsGet Method for RepositoriesWorkspaceRepoSlugComponentsGet
 * Returns the components that have been defined in the issue tracker.

This resource is only available on repositories that have the issue
tracker enabled.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugComponentsGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugComponentsGet(ctx _context.Context, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugComponentsGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugComponentsGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedComponents
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugComponentsGetExecute(r ApiRepositoriesWorkspaceRepoSlugComponentsGetRequest) (PaginatedComponents, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedComponents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugComponentsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/components"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	repoSlug string
	workspace string
	body *ExportOptions
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest) Body(body ExportOptions) ApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest {
	r.body = &body
	return r
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesExportPostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesExportPost Method for RepositoriesWorkspaceRepoSlugIssuesExportPost
 * A POST request to this endpoint initiates a new background celery task that archives the repo's issues.

For example, you can run:

curl -u <username> -X POST http://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/
issues/export

When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the
'Location' response header. This url is the endpoint for where the user can obtain their zip files."
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesExportPost(ctx _context.Context, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesExportPostExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesExportPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesExportPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/export"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	repoName string
	repoSlug string
	taskId string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetRequest) Execute() (IssueJobStatus, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet Method for RepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet
 * This endpoint is used to poll for the progress of an issue export
job and return the zip file after the job is complete.
As long as the job is running, this will return a 200 response
with in the response body a description of the current status.

After the job has been scheduled, but before it starts executing, this
endpoint's response is:

{
 "type": "issue_job_status",
 "status": "ACCEPTED",
 "phase": "Initializing",
 "total": 0,
 "count": 0,
 "pct": 0
}


Then once it starts running, it becomes:

{
 "type": "issue_job_status",
 "status": "STARTED",
 "phase": "Attachments",
 "total": 15,
 "count": 11,
 "pct": 73
}

Once the job has successfully completed, it returns a stream of the zip file.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoName The name of the repo
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param taskId The ID of the export task
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet(ctx _context.Context, repoName string, repoSlug string, taskId string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetRequest{
		ApiService: a,
		ctx: ctx,
		repoName: repoName,
		repoSlug: repoSlug,
		taskId: taskId,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return IssueJobStatus
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetRequest) (IssueJobStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IssueJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/export/{repo_name}-issues-{task_id}.zip"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_name"+"}", _neturl.PathEscape(parameterToString(r.repoName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", _neturl.PathEscape(parameterToString(r.taskId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesGetRequest) Execute() (PaginatedIssues, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesGet Method for RepositoriesWorkspaceRepoSlugIssuesGet
 * Returns the issues in the issue tracker.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesGet(ctx _context.Context, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedIssues
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesGetExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesGetRequest) (PaginatedIssues, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedIssues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesImportGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesImportGetRequest) Execute() (IssueJobStatus, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesImportGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesImportGet Method for RepositoriesWorkspaceRepoSlugIssuesImportGet
 * When using GET, this endpoint reports the status of the current import task. Request example:

```
$ curl -u <username> -X GET https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import
```

After the job has been scheduled, but before it starts executing, this endpoint's response is:

```
< HTTP/1.1 202 Accepted
{
    "type": "issue_job_status",
    "status": "PENDING",
    "phase": "Attachments",
    "total": 15,
    "count": 0,
    "percent": 0
}
```

Once it starts running, it is a 202 response with status STARTED and progress filled.

After it is finished, it becomes a 200 response with status SUCCESS or FAILURE.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesImportGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesImportGet(ctx _context.Context, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesImportGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesImportGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return IssueJobStatus
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesImportGetExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesImportGetRequest) (IssueJobStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IssueJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesImportGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/import"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesImportPostRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesImportPostRequest) Execute() (IssueJobStatus, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesImportPostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesImportPost Method for RepositoriesWorkspaceRepoSlugIssuesImportPost
 * A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All
existing issues will be deleted and replaced by the contents of the imported zip file.

Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name
"archive," which needs to be a file field:

```
$ curl -u <username> -X POST -F archive=@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import
```

When the import job is accepted, here is example output:

```
< HTTP/1.1 202 Accepted

{
    "type": "issue_job_status",
    "status": "ACCEPTED",
    "phase": "Attachments",
    "total": 15,
    "count": 0,
    "percent": 0
}
```
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesImportPostRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesImportPost(ctx _context.Context, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesImportPostRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesImportPostRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return IssueJobStatus
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesImportPostExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesImportPostRequest) (IssueJobStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IssueJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesImportPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/import"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetRequest) Execute() (PaginatedIssueAttachments, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet
 * Returns all attachments for this issue.

This returns the files' meta data. This does not return the files'
actual contents.

The files are always ordered by their upload date.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedIssueAttachments
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetRequest) (PaginatedIssueAttachments, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedIssueAttachments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	path string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete
 * Deletes an attachment.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param path Path to the file.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete(ctx _context.Context, issueId string, path string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		path: path,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", _neturl.PathEscape(parameterToString(r.path, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	path string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet
 * Returns the contents of the specified file attachment.

Note that this endpoint does not return a JSON response, but instead
returns a redirect pointing to the actual file that in turn will return
the raw contents.

The redirect URL contains a one-time token that has a limited lifetime.
As a result, the link should not be persisted, stored, or shared.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param path Path to the file.
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet(ctx _context.Context, issueId string, path string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		path: path,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", _neturl.PathEscape(parameterToString(r.path, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost
 * Upload new issue attachments.

To upload files, perform a `multipart/form-data` POST containing one
or more file fields.

When a file is uploaded with the same name as an existing attachment,
then the existing file will be replaced.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	changeId string
	issueId string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetRequest) Execute() (IssueChange, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet
 * Returns the specified issue change object.

This resource is only available on repositories that have the issue
tracker enabled.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param changeId The issue change id
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet(ctx _context.Context, changeId string, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetRequest{
		ApiService: a,
		ctx: ctx,
		changeId: changeId,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return IssueChange
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetRequest) (IssueChange, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IssueChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes/{change_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"change_id"+"}", _neturl.PathEscape(parameterToString(r.changeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
	q *string
	sort *string
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest) Q(q string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest {
	r.q = &q
	return r
}
func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest) Sort(sort string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest {
	r.sort = &sort
	return r
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest) Execute() (PaginatedLogEntries, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet
 * Returns the list of all changes that have been made to the specified
issue. Changes are returned in chronological order with the oldest
change first.

Each time an issue is edited in the UI or through the API, an immutable
change record is created under the `/issues/123/changes` endpoint. It
also has a comment associated with the change.

Note that this operation is changing significantly, due to privacy changes.
See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api)
for details.

```
$ curl -s https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes - | jq .

{
  "pagelen": 20,
  "values": [
    {
      "changes": {
        "priority": {
          "new": "trivial",
          "old": "major"
        },
        "assignee": {
          "new": "",
          "old": "evzijst"
        },
        "assignee_account_id": {
          "new": "",
          "old": "557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443"
        },
        "kind": {
          "new": "enhancement",
          "old": "bug"
        }
      },
      "links": {
        "self": {
          "href": "https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes/2"
        },
        "html": {
          "href": "https://bitbucket.org/evzijst/dogslow/issues/1#comment-2"
        }
      },
      "issue": {
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1"
          }
        },
        "type": "issue",
        "id": 1,
        "repository": {
          "links": {
            "self": {
              "href": "https://api.bitbucket.org/2.0/repositories/evzijst/dogslow"
            },
            "html": {
              "href": "https://bitbucket.org/evzijst/dogslow"
            },
            "avatar": {
              "href": "https://bitbucket.org/evzijst/dogslow/avatar/32/"
            }
          },
          "type": "repository",
          "name": "dogslow",
          "full_name": "evzijst/dogslow",
          "uuid": "{988b17c6-1a47-4e70-84ee-854d5f012bf6}"
        },
        "title": "Updated title"
      },
      "created_on": "2018-03-03T00:35:28.353630+00:00",
      "user": {
        "username": "evzijst",
        "nickname": "evzijst",
        "display_name": "evzijst",
        "type": "user",
        "uuid": "{aaa7972b-38af-4fb1-802d-6e3854c95778}",
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/users/evzijst"
          },
          "html": {
            "href": "https://bitbucket.org/evzijst/"
          },
          "avatar": {
            "href": "https://bitbucket.org/account/evzijst/avatar/32/"
          }
        }
      },
      "message": {
        "raw": "Removed assignee, changed kind and priority.",
        "markup": "markdown",
        "html": "<p>Removed assignee, changed kind and priority.</p>",
        "type": "rendered"
      },
      "type": "issue_change",
      "id": 2
    }
  ],
  "page": 1
}
```

Changes support [filtering and sorting](../../../meta/filtering) that
can be used to search for specific changes. For instance, to see
when an issue transitioned to "resolved":

```
$ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \
   -G --data-urlencode='q=changes.state.new = "resolved"'
```

This resource is only available on repositories that have the issue
tracker enabled.

N.B.

The `changes.assignee` and `changes.assignee_account_id` fields are not
a `user` object. Instead, they contain the raw `username` and
`account_id` of the user. This is to protect the integrity of the audit
log even after a user account gets deleted.

The `changes.assignee` field is deprecated will disappear in the
future. Use `changes.assignee_account_id` instead.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedLogEntries
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetRequest) (PaginatedLogEntries, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedLogEntries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
	body *IssueChange
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest) Body(body IssueChange) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest {
	r.body = &body
	return r
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest) Execute() (IssueChange, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost
 * Makes a change to the specified issue.

For example, to change an issue's state and assignee, create a new
change object that modifies these fields:

```
curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \
  -s -u evzijst -X POST -H "Content-Type: application/json" \
  -d '{
    "changes": {
      "assignee_account_id": {
        "new": "557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443"
      },
      "state": {
        "new": 'resolved"
      }
    }
    "message": {
      "raw": "This is now resolved."
    }
  }'
```

The above example also includes a custom comment to go alongside the
change. This comment will also be visible on the issue page in the UI.

The fields of the `changes` object are strings, not objects. This
allows for immutable change log records, even after user accounts,
milestones, or other objects recorded in a change entry, get renamed or
deleted.

The `assignee_account_id` field stores the account id. When POSTing a
new change and changing the assignee, the client should therefore use
the user's account_id in the `changes.assignee_account_id.new` field.

This call requires authentication. Private repositories or private
issue trackers require the caller to authenticate with an account that
has appropriate authorization.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return IssueChange
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostRequest) (IssueChange, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IssueChange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	commentId int32
	issueId string
	repoSlug string
	workspace string
	body *IssueComment
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest) Body(body IssueComment) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest {
	r.body = &body
	return r
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete
 * Deletes the specified comment.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param commentId The id of the comment.
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete(ctx _context.Context, commentId int32, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", _neturl.PathEscape(parameterToString(r.commentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	commentId int32
	issueId string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetRequest) Execute() (IssueComment, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet
 * Returns the specified issue comment object.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param commentId The id of the comment.
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet(ctx _context.Context, commentId int32, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return IssueComment
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetRequest) (IssueComment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IssueComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", _neturl.PathEscape(parameterToString(r.commentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	commentId int32
	issueId string
	repoSlug string
	workspace string
	body *IssueComment
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest) Body(body IssueComment) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest {
	r.body = &body
	return r
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest) Execute() (IssueComment, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut
 * Updates the content of the specified issue comment. Note that only
the `content.raw` field can be modified.

```
$ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \
  -X PUT -u evzijst \
  -H 'Content-Type: application/json' \
  -d '{"content": {"raw": "Lorem ipsum."}'
```
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param commentId The id of the comment.
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut(ctx _context.Context, commentId int32, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return IssueComment
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutRequest) (IssueComment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IssueComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", _neturl.PathEscape(parameterToString(r.commentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
	q *string
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest) Q(q string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest {
	r.q = &q
	return r
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest) Execute() (PaginatedIssueComments, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet
 * Returns a paginated list of all comments that were made on the
specified issue.

The default sorting is oldest to newest and can be overridden with
the `sort` query parameter.

This endpoint also supports filtering and sorting of the results. See
[filtering and sorting](../../../../../../meta/filtering) for more details.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedIssueComments
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetRequest) (PaginatedIssueComments, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedIssueComments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
	body *IssueComment
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest) Body(body IssueComment) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest {
	r.body = &body
	return r
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost
 * Creates a new issue comment.

```
$ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \
  -X POST -u evzijst \
  -H 'Content-Type: application/json' \
  -d '{"content": {"raw": "Lorem ipsum."}}'
```
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteRequest) Execute() (Issue, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdDelete Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdDelete
 * Deletes the specified issue. This requires write access to the
repository.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdDelete(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Issue
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdDeleteRequest) (Issue, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Issue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdGetRequest) Execute() (Issue, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdGet Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdGet
 * Returns the specified issue.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdGet(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdGetRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Issue
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdGetExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdGetRequest) (Issue, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Issue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 410 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdPutRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdPutRequest) Execute() (Issue, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdPutExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdPut Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdPut
 * Modifies the issue.

```
$ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \
  -u evzijst -s -X PUT -H 'Content-Type: application/json' \
  -d '{
  "title": "Updated title",
  "assignee": {
    "username": "evzijst"
  },
  "priority": "minor",
  "version": {
    "name": "1.0"
  },
  "component": null
}'
```

This example changes the `title`, `assignee`, `priority` and the
`version`. It also removes the value of the `component` from the issue
by setting the field to `null`. Any field not present keeps its existing
value.

Each time an issue is edited in the UI or through the API, an immutable
change record is created under the `/issues/123/changes` endpoint. It
also has a comment associated with the change.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdPutRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdPut(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdPutRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdPutRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Issue
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdPutExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdPutRequest) (Issue, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Issue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteRequest) Execute() (ModelError, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete
 * Retract your vote.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return ModelError
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteRequest) (ModelError, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ModelError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetRequest) Execute() (ModelError, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet
 * Check whether the authenticated user has voted for this issue.
A 204 status code indicates that the user has voted, while a 404
implies they haven't.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return ModelError
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetRequest) (ModelError, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ModelError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutRequest) Execute() (ModelError, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdVotePut Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdVotePut
 * Vote for this issue.

To cast your vote, do an empty PUT. The 204 status code indicates that
the operation was successful.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdVotePut(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return ModelError
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdVotePutRequest) (ModelError, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ModelError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdVotePut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteRequest) Execute() (ModelError, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete
 * Stop watching this issue.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return ModelError
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteRequest) (ModelError, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ModelError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetRequest) Execute() (ModelError, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet
 * Indicated whether or not the authenticated user is watching this
issue.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return ModelError
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetRequest) (ModelError, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ModelError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	issueId string
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutRequest) Execute() (ModelError, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut Method for RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut
 * Start watching this issue.

To start watching this issue, do an empty PUT. The 204 status code
indicates that the operation was successful.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param issueId The issue id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut(ctx _context.Context, issueId string, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return ModelError
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutRequest) (ModelError, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ModelError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch"
	localVarPath = strings.Replace(localVarPath, "{"+"issue_id"+"}", _neturl.PathEscape(parameterToString(r.issueId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugIssuesPostRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	repoSlug string
	workspace string
	body *Issue
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesPostRequest) Body(body Issue) ApiRepositoriesWorkspaceRepoSlugIssuesPostRequest {
	r.body = &body
	return r
}

func (r ApiRepositoriesWorkspaceRepoSlugIssuesPostRequest) Execute() (Issue, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugIssuesPostExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugIssuesPost Method for RepositoriesWorkspaceRepoSlugIssuesPost
 * Creates a new issue.

This call requires authentication. Private repositories or private
issue trackers require the caller to authenticate with an account that
has appropriate authorization.

The authenticated user is used for the issue's `reporter` field.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugIssuesPostRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesPost(ctx _context.Context, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugIssuesPostRequest {
	return ApiRepositoriesWorkspaceRepoSlugIssuesPostRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Issue
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugIssuesPostExecute(r ApiRepositoriesWorkspaceRepoSlugIssuesPostRequest) (Issue, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Issue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugIssuesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/issues"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugMilestonesGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugMilestonesGetRequest) Execute() (PaginatedMilestones, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugMilestonesGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugMilestonesGet Method for RepositoriesWorkspaceRepoSlugMilestonesGet
 * Returns the milestones that have been defined in the issue tracker.

This resource is only available on repositories that have the issue
tracker enabled.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugMilestonesGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugMilestonesGet(ctx _context.Context, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugMilestonesGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugMilestonesGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedMilestones
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugMilestonesGetExecute(r ApiRepositoriesWorkspaceRepoSlugMilestonesGetRequest) (PaginatedMilestones, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedMilestones
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugMilestonesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/milestones"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	milestoneId int32
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetRequest) Execute() (Milestone, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet Method for RepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet
 * Returns the specified issue tracker milestone object.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param milestoneId The milestone's id
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet(ctx _context.Context, milestoneId int32, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetRequest{
		ApiService: a,
		ctx: ctx,
		milestoneId: milestoneId,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Milestone
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetExecute(r ApiRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetRequest) (Milestone, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Milestone
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/milestones/{milestone_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"milestone_id"+"}", _neturl.PathEscape(parameterToString(r.milestoneId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugVersionsGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	repoSlug string
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugVersionsGetRequest) Execute() (PaginatedVersions, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugVersionsGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugVersionsGet Method for RepositoriesWorkspaceRepoSlugVersionsGet
 * Returns the versions that have been defined in the issue tracker.

This resource is only available on repositories that have the issue
tracker enabled.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugVersionsGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugVersionsGet(ctx _context.Context, repoSlug string, workspace string) ApiRepositoriesWorkspaceRepoSlugVersionsGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugVersionsGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return PaginatedVersions
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugVersionsGetExecute(r ApiRepositoriesWorkspaceRepoSlugVersionsGetRequest) (PaginatedVersions, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedVersions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugVersionsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoriesWorkspaceRepoSlugVersionsVersionIdGetRequest struct {
	ctx _context.Context
	ApiService *IssueTrackerApiService
	repoSlug string
	versionId int32
	workspace string
}


func (r ApiRepositoriesWorkspaceRepoSlugVersionsVersionIdGetRequest) Execute() (Version, *_nethttp.Response, error) {
	return r.ApiService.RepositoriesWorkspaceRepoSlugVersionsVersionIdGetExecute(r)
}

/*
 * RepositoriesWorkspaceRepoSlugVersionsVersionIdGet Method for RepositoriesWorkspaceRepoSlugVersionsVersionIdGet
 * Returns the specified issue tracker version object.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. 
 * @param versionId The version's id
 * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. 
 * @return ApiRepositoriesWorkspaceRepoSlugVersionsVersionIdGetRequest
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugVersionsVersionIdGet(ctx _context.Context, repoSlug string, versionId int32, workspace string) ApiRepositoriesWorkspaceRepoSlugVersionsVersionIdGetRequest {
	return ApiRepositoriesWorkspaceRepoSlugVersionsVersionIdGetRequest{
		ApiService: a,
		ctx: ctx,
		repoSlug: repoSlug,
		versionId: versionId,
		workspace: workspace,
	}
}

/*
 * Execute executes the request
 * @return Version
 */
func (a *IssueTrackerApiService) RepositoriesWorkspaceRepoSlugVersionsVersionIdGetExecute(r ApiRepositoriesWorkspaceRepoSlugVersionsVersionIdGetRequest) (Version, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Version
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssueTrackerApiService.RepositoriesWorkspaceRepoSlugVersionsVersionIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/versions/{version_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", _neturl.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version_id"+"}", _neturl.PathEscape(parameterToString(r.versionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", _neturl.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
